---
title: Java 类和接口
layout: post
author: chuizi
---

* any list
{:toc}

# 类和对象

类是对一个实物或者概念的抽象和封装。现实生活中，实物具有某些特征和属性，同时也有一些特定的行为，对应的，类也有自己的属性和行为，我们把它定义为成员变量和成员方法。  

举个例子，我们定义了一个类 Animal 表示动物，动物有年龄属性，所以我们给类定义了一个变量 age，同时动物还有吃吃吃的行为，所以我们再给类定义一个方法 eat。下面是一个 Animal 类的简单定义  

```
public class Animal {

  public int age;
  
  Animal(int age) {
    this.age = age;
  }
  
  public void eat() {
    System.out.println("delicious");
  }
}
```

那类定义后要如何使用呢。这里需要了解一下对象的概念。  

对象是类的实例化，创建后拥有类中定义的所有成员变量和成员方法。我们可以先简单认为，类是一种定义，对象是类在内存中的实现。  

比如对于上面的 Animal 类，需要先用关键字 `new` 创建出对应的对象，然后再调用对象的成员变量和方法，如下所示  

```
Animal animal = new Animal(2);
animal.age = 1;
animal.eat();
```

第一行代码创建了一个 Animal 对象，`new Animal(2)` 调用了构造方法，给实例的 age 变量赋值 2；第二行代码将 animal 对象的 age 变量修改为 1；第三行代码调用了 animal 对象的 eat 方法。  

总结一下，类具体由以下几部分组成  

* 构造方法，用于初始化实例变量
* 实例变量，归属于具体实例的变量，每当创建一个类的实例时，都会为该实例变量分配一个单独的内存空间
* 静态变量，被类和所有实例共享，存储在一个公共的内存空间，当一个变量和特定的实例无关时
* 实例方法，归属于具体实例的方法，可以访问实例变量和静态变量，可以调用静态方法
* 静态方法，被类和所有实例共享，只能访问静态变量和静态方法，不能访问实例变量和实例方法

如果变量/方法不依赖具体的实例，就应该将其定义为静态变量/方法。  

如果类没有定义构造方法，类中会隐式地定义一个方法体为空的无参构造方法，即默认构造方法。

# 父类、抽象类和接口

## 父类

当我们想为猫咪定义一个类时，会怎么做呢。假设我们已经定义了一个 Animal 的类，那需要从零开始定义一个 Cat 类吗？答案是不需要的。因为 Cat 是在 Animal 的基础上更具象的实物，所以可以继承自 Animal。像下面这样  

```
class Cat extends Animal {

  private String color;

  Cat(int age) {
    super(age);
  }

  public String getColor() {
    return this.color;
  }

  public void setColor(String color) {
    this.color = color;
  }
}
```

我们使用 `extends` 关键字从 Animal 继承出类 Cat，这时 Cat 将拥有 Animal 定义的成员变量和成员方法。同时，Cat 也为自己额外定义了 color 变量和 getColor 方法。  

当我们需要定义一个 Dog 类时，同样地可以继承自 Animal，继承其变量和方法。  

从上面的例子可以看出继承的优点。继承可以让我们进行不同层次的抽象，以便提高代码的复用性和可维护性。  

在类 Cat 的构造方法中，使用 `super(age)` 调用了父类的构造方法。继承关系中存在这一条构造方法链，子类会先调用父类的构造方法，再执行自己的构造方法。如果没有显示地调用父类构造方法，编译器会默认地添加 super 作为构造方法的第一条语句。  

在继承关系中，被继承的类称为父类，继承的类称为子类。  

## 抽象类

我们现在知道，类可以通过继承，获得另一个类的变量和方法，比如 Cat 和 Dog 类都继承自 Animal，他们的实例也拥有了 eat 方法。这时候，Cat 和 Dog 的 eat 方法的逻辑是完全一样的。但是实际上，Animal 只知道动物都有吃这个行为，但是不知道不同的动物分别是怎么吃东西的，那要如何实现呢。答案是抽象类。抽象类允许我们在父类中定义方法，但是不定义逻辑。逻辑由子类各自定义。比如  

```
package demo;

public abstract class Animal {
	
  public abstract void eat();
}


class Cat extends Animal {

  @Override
  public void eat() {
    System.out.println("I like fish!");
  }

}

class Dog extends Animal {

  @Override
  public void eat() {
    System.out.println("I like bone!");
  }

}
```

上面的代码，首先定义了抽象类 Animal，其中有个方法 eat，这个方法只有签名，没有具体的实现，我们称之为抽象方法。然后定义了 Cat 和 Dog 类，并实现了 eat 方法的具体逻辑。  

也就是说，抽象类让我们有能力定义类有哪些方法，而不定义方法的实现。方法的行为由各个子类实现。  

抽象类由 `abstract` 关键字修饰，抽象方法由 `abstract` 修饰。抽象类和方法有以下限制  

* 抽象类不能使用 `new` 关键字实例化。抽象类意味着可能存在抽象方法，无法创建一个包含未实现方法的实例。
* 抽象方法不能定义成静态方法。静态方法必须有对应的实现以便通过类名直接调用，所以不适用于没有实现的抽象方法。
* 子类可以重写父类的抽象方法并将其定义为抽象的。  

## 接口

在 Java 中，类只允许继承自一个父类。当一个类希望实现多组方法时，怎么办呢？可以使用接口。  

```
public interface Runable {
  public abstract void run();
}

class Cat extends Animal implements Runable {

  @Override
  public void eat() {
    System.out.println("I like fish!");
  }

  @Override
  public void run() {	
  }

}
```

上图中，Cat 类不仅继承了 Animal 类，还通过 `implements` 关键字实现了 Runable 接口。Runable 接口定义了 run 方法，但是没有具体实现；Cat 给出了 run 方法的具体实现。  

从上面可以看出，接口和抽象类有点类似，都是为继承类/实现类定义方法而不定义实现。接口的优点在于，类可以实现多个接口，但只能继承一个抽象类。如果某个类需要实现不同类别的方法，会显得格外有用。  

接口的所有成员变量都是 public static final ，所有方法都是 public abstract，所以在接口中定义这些成员时可以省略修饰符。  

为什么成员变量必须是 public static final 呢，因为接口是高层次的抽象，对外提供一个统一的协议，成员变量作为协议的组成部分，自然也希望它是公共的、静态的、不可变的。 

接口除了定义默认的 `public abstract` 方法，还可以定义 `public static` 和 `public default`，分别表示静态方法和默认方法。其中，默认方法主要是为了在为接口定义新的方法时，可以兼容之前实现了接口的类。  

## 多态

```
Animal x = new Cat();
// 执行的是 Cat 中定义的 eat 方法
x.eat();
    
Runable y = new Cat();
// 执行的是 Cat 中定义的 run 方法
y.run();
```
像上面这样，变量的声明类型和实际类型不同（实际类型是声明类型的子类型）。当声明类型是父类/接口，实际类型是子类或者接口的实现类时，调用的方法是实际类型的方法。这就是多态。  

当通过该变量访问它所引用的对象的实例变量时，该实例变量的值取决于该变量的声明类型；当通过该变量来调用它所引用的对象的方法时，该方法取决于它实际引用的对象的类型。  

# 修饰符

在定义类、变量和方法时，可以添加一些修饰符限制它们的使用。

## 可见性修饰符

可见性修饰符一共有四种，分类是  

* public
* protected
* 默认可见性，即没有显式使用其他修饰符
* private

可见性用于定义类和成员的访问范围，限制变量和方法能否在类外访问。访问范围具体包括无访问限制、在子类中可以访问、在同个包内可以访问，以及在同个类中可以访问。  

可见性修饰符的可见性如下  

|可见性修饰符|无访问限制|子类可以访问|同个包内可以访问|同个类中可以访问|
|:---|:---|:---|:---|:---|
|public|是|是|是|是|
|protected||是|是|是|
|默认可见性|||是|是|
|private||||是|

这四个修饰符的可见范围是：public > protected > 默认可见性 > private。  

public、默认可见性可以用于类或者类的成员，private、protected 只能用于类的成员。  

值得注意的是，可见性修饰符限制的是成员在类外是否可以访问，而不是在实例外是否可以访问。对于 private 的成员，是实例外是允许被访问的，前提是上下文环境是在同个类中。  

## 静态修饰符

静态修饰符用 static 关键字，用于修饰类的成员，表示变量/方法是类的所有示例所共享的。  

## final 修饰符

final 修饰符可以修饰类、变量和方法。被 final 修饰的类不能被继承，被 final 修饰的方法不能被重写(会编译错误)，被 final 修饰的变量是一个常量。  

## abstract 修饰符

abstract 修饰符可以修饰类和方法，表示抽象类和抽象方法。  

## default 修饰符

default 修饰符只能用于接口中的方法 ，用于表示接口中抽象方法的默认实现。  


# this 和 super

关键字 this 指向实例自身，也可以用于构造方法内部调用同类的另一个构造方法；关键字 super 指向父类，也可以用于构造方法内部调用父类的构造方法。  


# 方法的重载和重写

## 重载

重载是指提供相同的方法名，不同的参数列表，以支持使用不同的参数调用方法。不同的参数是指参数数量、参数类型和参数的顺序。  

方法的重载可以发生在同个类中，也可以发生在父类和子类间。  

## 重写

重写是指子类修改父类中某个方法的实现，需要定义和父类完全相同的方法签名（方法名称 + 按照一定顺序的拥有类型的参数列表）。

重写时有一些规则  

* 重写方法的返回类型与被重写方法的返回类型一样，或者是其子类型，否则会编译错误
* final 方法不能被重写
* 静态方法不能被重写。如果子类定义了一样签名的静态方法，就必须定义和父类兼容的返回参数。此时父类和子类同时存在两个同名的静态方法，父类的静态方法实现并不会被子类覆盖掉。如果通过实例调用静态方法，调用时使用的方法取决于声明实例时的类型。（也就是说不能应用到多态的特征啦）
* 私有方法不能被重写。私有方法在父类以外是不可访问的，对子类也是不可见的，所以不能被重写。子类可以定义一样的签名的方法，这个方法和父类的方法没有任何关系。如果通过实例调用该方法，调用时使用的方法取决于声明实例时的类型。（也就是说不能应用到多态的特征啦）
* 重写时，子类可以提高父类方法的可见性，但是不能降低可见性