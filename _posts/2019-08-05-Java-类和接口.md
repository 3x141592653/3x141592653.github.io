---
title: Java 类和接口
layout: post
author: chuizi
---

* any list
{:toc}

# 类

# 类的组成，属性和方法

实例变量
静态变量，被所有类实例共享，存储在一个公共的内存空间
实例方法
静态方法，不能访问实例变量和实例方法
构造方法

如果变量/方法不依赖具体的实例，就应该将其定义为静态变量/方法

如果没有定义构造方法，类中会隐式地定义一个方法体为空的无参构造方法，即默认构造方法。

# 修饰符

可见性修饰符：public / protect / private / 默认可见性
可见性修饰符用于限制变量和方法能否在类（而不是实例）外访问，比如 private 的变量可以在同个类的其他实例中访问

如果是 private，子类也不能访问

A 在同一个类内可以访问
B 在同一个包内可以访问
C 在子类中可以访问
D 没有访问限制

public A B C D
protected A B C
默认可见性 A B
private A

public、默认可见性可以用于类或者类的成员
private、protected 只能用于类的成员

静态修饰符 status

final 被 final 修饰的类不能被继承，被 final 修饰的方法不能被重写(会编译错误)，被 final 修饰的字段是一个常量



# 继承

# 父类、抽象类和接口

构造方法链，子类会先调用父类的构造方法，再执行自己构造方法中的逻辑。如果没有显示地调用父类构造方法，编译器会默认地添加 super 作为构造方法的第一条语句

# this 和 super

关键字 this 指向实例自身，也可以用于构造方法内部调用同类的另一个构造方法

# 多态

demo.test()，只能调用重写的方法，如果没有重写，那调用的还是父类的方法

# 重载和重写

重载和重写对修饰符的影响，会覆盖吗

什么是重载
重写可以发生在同个类中，也可以发生在父类和子类中

可以重载构造函数

什么是重写
子类修改父类中某个方法的实现，称为方法重写。
重写有几个地方要注意
1. 重写时，需要定义与被重写的方法一样的签名（方法名称 + 按照一定顺序的拥有类型的参数列表）。即如果方法的签名一样，则会认为是要重写父类的方法。
2. 返回类型与被重写的方法返回类型一样或者兼容（兼容是指子类型），如果不兼容则会编译错误。
3. 当实例方法可访问时才能被重写，如果是私有方法，这个方法在父类以外是不可访问的，所以不能被重写，子类可以定义一样的签名的方法，这个方法和父类的方法没有任何关系。
4. 子类重写的方法可见性不能比父类低
5. 静态方法能被继承但是不能被重写，如果子类定义了一样签名的静态方法，就必须定义和父类兼容的返回参数，此时会隐藏掉父类的静态方法


因为继承成员变量和继承方法之间这样的差别，所以对于一个引用类型的变量而言，
当通过该变量访问它所引用的对象的实例变量时，该实例变量的值取决于该变量的声明类型；
当通过该变量来调用它所引用的对象的方法时，该方法取决于它实际引用的对象的类型。

父类和子类的重写

父类和子类的重载

接口的重写

接口的重载